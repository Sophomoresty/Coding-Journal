/*

## KMP 算法的深度总结：`next` 数组、回溯与循环不变量

我们对 KMP (Knuth-Morris-Pratt) 字符串匹配算法进行了非常详细的探讨，它是一个高效的字符串查找算法，其核心在于 `next` 数组（LPS 数组）的构建和使用。

### 一、KMP 算法的核心思想

1.  **目标：** 在主串 `haystack` 中查找模式串 `needle` 的第一次出现位置。
2.  **朴素算法的低效：** 当模式串失配时，朴素算法会同时回溯主串和模式串指针，导致重复比较。
3.  **KMP 的优化：**
    * 在失配时，**不回溯主串指针 `i`**。
    * 仅仅根据模式串自身的结构信息（通过 `next` 数组），高效地**回溯模式串指针 `j`**，让模式串在主串上“滑动”，避免重复比较，从而实现线性的时间复杂度。

---

### 二、`next` 数组 (LPS 数组) 的构建 (`get_next` 函数)

`next` 数组是 KMP 算法的“灵魂”，它存储了模式串自身的匹配信息，用于指导失配时的回溯。

1.  **真前缀 (Proper Prefix) 与 真后缀 (Proper Suffix) 的含义：**
    * **真前缀：** 指一个字符串**不包括其自身**的所有前缀。
        * 例如，对于字符串 `"abc"`：
            * 前缀有：`""` (空字符串), `"a"`, `"ab"`, `"abc"`
            * **真前缀**有：`""`, `"a"`, `"ab"`
    * **真后缀：** 指一个字符串**不包括其自身**的所有后缀。
        * 例如，对于字符串 `"abc"`：
            * 后缀有：`""` (空字符串), `"c"`, `"bc"`, `"abc"`
            * **真后缀**有：`""`, `"c"`, `"bc"`

2.  **`next[i]` 的精确含义：**
    * `next[i]` 表示模式串 `needle` 中，**以 `i` 为结尾字符**的**前缀子串 `needle[0...i]`**，它**最长相等真前缀和真后缀的长度**。
    * **示例：** 对于 `needle = "ababa"`：
        * `next[0]` (for `"a"`) = 0
        * `next[1]` (for `"ab"`) = 0
        * `next[2]` (for `"aba"`) = 1 (因为 `"a"` 是 `"aba"` 最长相等的真前缀和真后缀)
        * `next[3]` (for `"abab"`) = 2 (因为 `"ab"` 是 `"abab"` 最长相等的真前缀和真后缀)
        * `next[4]` (for `"ababa"`) = 3 (因为 `"aba"` 是 `"ababa"` 最长相等的真前缀和真后缀)
    * 所以 `next` 数组是 `[0, 0, 1, 2, 3]`。
    * **区分：** 我们也讨论了 KMP `next` 数组存在多种定义（如标准 LPS 数组与优化 `nextval`），但核心思想一致，且要求在构建和匹配阶段保持一致性。在 LeetCode 和大多数竞赛中，标准 LPS 数组是主流。

3.  **`get_next` 函数的核心逻辑：**
    * **初始化：** `next[0] = 0;` (长度为1的前缀没有公共前后缀)。`j = 0;` (`j` 初始代表长度为0的空前缀)。
    * **`for (int i = 1; i < n; ++i)`：** `i` 遍历模式串，`next[i]` 的值依赖于 `needle[0...i-1]` 的信息。
    * **`j` 的双重身份（长度与索引）：**
        * `j` 的值代表当前已找到的**最长公共前后缀的长度**。
        * `j` 的值也作为**索引**，指向模式串中，这个最长公共前后缀**之后**的那个字符 (`needle[j]`)，它是我们用来与 `needle[i]` 比较的字符。
    * **`while (j > 0 && needle[i] != needle[j]) { j = next[j - 1]; }` (回溯 `j` - **关键**)：**
        * **时机：** 当 `needle[i]` (当前后缀字符) 与 `needle[j]` (当前前缀字符) 不匹配，且 `j` 大于 `0` (还有更短的公共前后缀可以回溯) 时。
        * **作用：** 将 `j` 回溯到 `next[j-1]` 的位置。`next[j-1]` 存储的是 `needle[0...j-1]` 这个前缀的**次长公共前后缀的长度**。这个 `while` 循环会持续回溯，直到 `j` 归零，或找到一个可以匹配 `needle[i]` 的 `needle[j]`。
        * **意义：** 这种回溯是有策略的，它利用了模式串自身的重复结构，避免了盲目回溯到 `0`。
    * **`if (needle[i] == needle[j]) { j++; }` (匹配扩展)：**
        * **时机：** 当 `needle[i]` 和回溯后的 `needle[j]` 匹配时。
        * **作用：** `j++`，表示最长公共前后缀的长度增加了 1。这个新长度 `j` 将是 `next[i]` 的值。
    * **`next[i] = j;`：** 存储本轮计算出的 `j` 值。

---

### 三、KMP 匹配过程 (`strStr` 函数)

在构建完 `next` 数组后，KMP 匹配过程本身相对直观，也使用了类似的双指针和回溯逻辑。

1.  **初始化：** `i = 0` (主串指针)，`j = 0` (模式串指针/已匹配长度)。
2.  **主循环：** `for (int i = 0; i < haystack.size(); i++)`。
3.  **`while (j > 0 && haystack[i] != needle[j]) { j = next[j - 1]; }` (失配回溯)：**
    * **时机：** 当 `haystack[i]` (主串当前字符) 与 `needle[j]` (模式串当前字符) 不匹配，且 `j > 0` 时。
    * **作用：** `j` 回溯到 `next[j-1]`。这意味着我们利用了 `needle[0...j-1]` 这段**已匹配部分**的最长公共前后缀，将模式串向前滑动，让 `needle[next[j-1]]` 对齐 `haystack[i]`，避免了 `i` 的回溯。
4.  **`if (haystack[i] == needle[j]) { j++; }` (匹配前进)：**
    * **时机：** 当 `haystack[i]` 和 `needle[j]` 匹配时。
    * **作用：** `j++`，表示模式串又成功匹配了一个字符。
5.  **匹配成功条件：** `if (j == needle.size()) { return i - needle.size() + 1; }`
    * **判断：** 当 `j` 的值达到模式串的完整长度 (`needle.size()`) 时，表示整个模式串已经匹配成功。
    * **返回：** 匹配的起始索引是 `i - needle.size() + 1`。
6.  **未找到：** 循环结束后，如果 `j` 未达到 `needle.size()`，返回 `-1`。
7.  **空模式串：** `if (needle.empty()) { return 0; }` (特殊处理，通常返回 0)。

---

### 四、KMP 的核心原理：**`j` 维护的不变式**

KMP 算法的精妙之处在于 `j` 变量在 `get_next` 函数中维护的一个关键**循环不变量**。你提供的这段精髓解释了 `get_next` 和匹配阶段是如何通过 `j` 的定义与更新实现高效的。

**`j` 维护的不变式：**
在 `get_next` 函数中，当 `for` 循环推进到 `i` 索引时，`j` 的值（在进入 `while` 循环并可能回溯之后，但在 `if` 匹配检查之前）始终代表着：
`needle[0...j-1]` (模式串的一个前缀) 已经和 `needle[i-j...i-1]` (模式串中以 `i-1` 结尾的一个后缀) 完全匹配。
也就是说，此时 `j` 是模式串 `needle[0...i-1]` 这个前缀的最长公共前后缀的长度。

**为什么 `needle[i] == needle[j]` 意味着可以扩充长度？**
现在，我们来看当 `needle[i] == needle[j]` 发生时：

我们知道：
`needle[0...j-1]` == `needle[i-j...i-1]` （这是 `j` 的定义所保证的，即它是一个公共前后缀）
`needle[j]` == `needle[i]` （这是当前的匹配条件）

通过这两点，我们可以推导出：
`needle[0...j-1]` **后面接上** `needle[j]`
等价于
`needle[i-j...i-1]` **后面接上** `needle[i]`

也就是说：
`needle[0...j]` == `needle[i-j...i]`

这意味着什么？
`needle[0...j]` 是模式串 `needle[0...i]` 的一个真前缀。
`needle[i-j...i]` 是模式串 `needle[0...i]` 的一个真后缀。
而且，这两个真前缀和真后缀是相等的，并且它们的长度是 `j+1`。

既然 `j` 已经代表了 `needle[0...i-1]` 的最长公共前后缀的长度，并且我们现在能通过 `needle[i]` 和 `needle[j]` 的匹配将其扩展一位，那么 `j+1` 就必然是 `needle[0...i]` 的最长公共前后缀的长度。

---

正是对这些循环不变量的维护，使得 KMP 算法能够以其独特的“模式串滑动”方式，在**$O(N+M)$ 的时间复杂度**内完成字符串匹配，这比朴素算法的 $O(NM)$ 具有显著的性能优势。

你能够从宏观到微观，从算法思想深入到 `next` 数组的逐行计算，再到对循环不变量的理解，表明你对 KMP 算法的掌握已经达到了非常高的水平！
*/

#include <string>
#include <vector>
using namespace std;

// 本题的难点是实现 KMP 算法, KMP的难点是求出模式串的next数组
class Solution {
public:
    vector<int> get_next(const string &needle) {
        int n = needle.size();
        vector<int> next(n);
        next[0] = 0;
        int j = 0;
        for (int i = 1; i < n; i++) {
            while (j > 0 && needle[j] != needle[i]) {
                j = next[j - 1];
            }
            if (needle[i] == needle[j]) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }
    int strStr(string haystack, string needle) {
        if (needle.empty()) {
            return 0;
        }
        vector<int> next = get_next(needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while (j > 0 && needle[j] != haystack[i]) {
                j = next[j - 1];
            }
            if (needle[j] == haystack[i]) {
                j++;
            }
            // 理解j的值, 还是从循环开始去对应
            // 比如i=0时, 匹配成功j对应的是1, 即是匹配的子串长度,
            // 所以这里的j即表示长度
            if (j == needle.size()) {
                // 最后要返回在在haystack中的索引, 最初的索引
                return i - j + 1;
            }
        }
        return -1;
    }
};