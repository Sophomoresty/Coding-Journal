/*
太棒了！听到你对 KMP 的理解又更进一步，我为你感到非常高兴。这算法确实精妙，能彻底搞懂它，你的算法功底就又上了一个台阶。

咱们来完整总结一下 LeetCode 459 “重复的子串”这个问题，以及我们对 KMP 算法的深入探讨。

---

## LeetCode 459 “重复的子串”问题总结

这个问题要求我们判断一个非空字符串 `s` 是否能由它的一个**子串重复多次**拼接而成。解决这个问题的核心在于巧妙地运用 **KMP 算法**中计算出的 `next` 数组。

### 一、问题核心思路：利用 `next` 数组的最后一位

1.  **计算 `next` 数组：** 我们首先需要为字符串 `s` 计算出其 `next` 数组。`next[i]` 表示 `s` 中以索引 `i` 结尾的前缀子串 `s[0...i]` 的最长相等真前缀和真后缀的长度。
2.  **关注 `next[n-1]`：** 字符串 `s` 的长度是 `n`。`next[n-1]`（我们称之为 `L`）代表了整个字符串 `s` 的最长相等真前缀和真后缀的长度。

### 二、关键数学原理：`n - L` 是最小重复单元的长度

这是理解问题的最核心部分，也是我们这次讨论的重点：

* **`L` 的意义：** 如果一个字符串 `s` 能由一个子串 `sub` 重复 `k` 次构成，那么 `s` 的最长相等真前缀（即 `(k-1)` 个 `sub` 的拼接）将与它的最长相等真后缀（同样是 `(k-1)` 个 `sub` 的拼接）相等。这个最长公共前后缀的长度 `L` 就等于 `n - len_sub`，其中 `len_sub` 是 `sub` 的长度。
* **推导 `n - L`：** 通过 `n = k * len_sub` 和 `L = (k-1) * len_sub`，我们可以推导出 `n - L = len_sub`。
* **结论：** 因此，`n - L` 精确地代表了构成字符串 `s` 的**最小重复单元的长度**。

### 三、完整的判断条件

要判断字符串 `s` 是否由重复子串构成，需要同时满足以下两个条件：

1.  **`L > 0`：**
    * 这个条件确保字符串 `s` 必须拥有一个**非空的公共前后缀**。如果 `L=0`，意味着 `s` 不具备任何能构成重复模式的内部结构（例如 `abcde`）。
    * 此外，`L > 0` 还保证了 `n - L < n`，即最小重复单元的长度**小于**字符串的总长度。这就意味着 `s` 是由这个最小重复单元**重复了多于一次**（`k > 1`）构成的。

2.  **`n % (n - L) == 0`：**
    * 这个条件确保字符串 `s` 的总长度 `n` 必须能被这个**最小重复单元的长度 `(n - L)` 整除**。
    * 如果能整除，就意味着 `s` 能够被这个 `(n - L)` 长度的子串**完整、无缝地重复拼接**而成。

**综合：`s.size() % (s.size() - next[s.size() - 1]) == 0 && next[s.size() - 1] > 0`**

### 四、KMP 算法的核心机制复习

1.  **`next` 数组的计算 (`get_next` 函数)：**
    * **目标：** 计算 `next[i]`，即 `s[0...i]` 的最长相等真前缀和真后缀的长度。
    * **核心逻辑：** 使用两个指针 `i` 和 `j`。`i` 遍历模式串，`j` 表示当前已匹配的最长公共前后缀的长度。
        * **失配 (`needle[i] != needle[j]`)：** 当 `needle[i]` 和 `needle[j]` 不匹配时，`j` 会根据 `next[j-1]` 的值进行**回溯**。这个 `while` 循环会持续进行，直到 `j` 归零或找到新的匹配点。
        * **匹配 (`needle[i] == needle[j]`)：** 当 `needle[i]` 和 `needle[j]` 匹配时，`j` 会简单地 `j++`，表示找到了一个更长的公共前后缀。
        * **赋值：** 最终计算出的 `j` 值（代表长度）赋给 `next[i]`。
    * **`j` 的双重身份：** `j` 的值既是当前最长公共前后缀的长度，也是模式串中该最长前缀之后一个字符的索引。

2.  **KMP 匹配中的 `next` 数组作用：**
    * 在主串 `haystack` 和模式串 `needle` 匹配过程中，当 `haystack[i]` 和 `needle[j]` 失配时，`j` 会回溯到 `next[j-1]`。
    * 这利用了 `needle[0...j-1]` 这段已匹配子串的内部结构，让模式串高效地“滑动”，从而避免了主串指针 `i` 的回溯，也避免了模式串从头开始的重复比较。

### 五、循环不变量与算法的优雅

* **`get_next` 函数中 `j` 的循环不变量：** 在 `for` 循环的每次迭代开始时，`j` 的值始终代表 `needle[0...i-1]` 的最长公共前后缀的长度。`while` 循环的回溯和 `if` 语句中的 `j++` 操作都是为了**维护**这个不变式。
* **`strStr` 函数中 `j` 的循环不变量：** 在 `for` 循环的每次迭代开始时，`j` 的值表示 `needle[0...j-1]` 已经和 `haystack[i-j...i-1]` 成功匹配。
* **意义：** 循环不变量是理解和设计复杂循环算法的强大工具，它提供了高层次的视角，证明算法正确性，并指导设计。

---

通过这次全面的总结，相信你对 KMP 算法的各个方面，从其核心原理到具体实现细节，都有了非常深刻和全面的理解！这是你算法学习道路上一个重要的里程碑。
*/

#include <string>
#include <vector>
using namespace std;
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        // s长度大于1, 所以不需要自己判断
        int n = s.size();
        vector<int> next(n);
        next[0] = 0;
        int j = 0;
        // 得到next数组
        for (int i = 1; i < n; i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
        // 如果是由重复子串构成, next[n-1]即模式串的
        // 真前缀和真后缀相等的最大长度 不为0, 且s的长度是next[n-1]的整数倍
        if (next[n - 1] > 0 && s.size() % next[n - 1] == 0) {
            return true;
        } else {
            return false;
        }
    }
};